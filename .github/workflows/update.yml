name: Update Hayase

on:
  schedule:
    # Check for updates every 6 hours
    - cron: "0 */6 * * *"
  workflow_dispatch:
    # Allow manual trigger

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v8

      - name: Setup Nix cache
        uses: DeterminateSystems/magic-nix-cache-action@v2

      - name: Check for new release
        id: check_release
        run: |
          # Get latest release from GitHub API
          LATEST_RELEASE=$(curl -s "https://api.github.com/repos/ThaUnknown/miru/releases/latest" | jq -r '.tag_name' | sed 's/^v//')
          CURRENT_VERSION=$(grep -o 'version = "[^"]*"' flake.nix | sed 's/version = "\(.*\)"/\1/')

          echo "Latest release: $LATEST_RELEASE"
          echo "Current version: $CURRENT_VERSION"

          # Debug: Show available assets for the latest release
          echo "Available assets for v$LATEST_RELEASE:"
          curl -s "https://api.github.com/repos/ThaUnknown/miru/releases/latest" | jq -r '.assets[] | .name'

          if [ "$LATEST_RELEASE" != "$CURRENT_VERSION" ]; then
            echo "New version available: $LATEST_RELEASE"
            echo "needs_update=true" >> $GITHUB_OUTPUT
            echo "new_version=$LATEST_RELEASE" >> $GITHUB_OUTPUT
          else
            echo "No update needed"
            echo "needs_update=false" >> $GITHUB_OUTPUT
          fi

      - name: Update flake
        if: steps.check_release.outputs.needs_update == 'true'
        run: |
          NEW_VERSION="${{ steps.check_release.outputs.new_version }}"

          # Update version in flake.nix
          sed -i "s/version = \"[^\"]*\"/version = \"$NEW_VERSION\"/" flake.nix

          # Function to get hash for a URL using multiple methods
          get_hash() {
            local url="$1"
            local platform="$2"
            
            echo "Fetching $platform hash for: $url"
            
            # Check if URL exists first with more verbose output
            echo "Checking if URL exists..."
            if ! curl --head --silent --fail "$url"; then
              echo "✗ $platform asset not found: $url"
              echo "Trying to list available assets..."
              
              # List all available assets for this release
              echo "Available assets for v${NEW_VERSION}:"
              curl -s "https://api.github.com/repos/ThaUnknown/miru/releases/tags/v${NEW_VERSION}" | jq -r '.assets[]? | .name' 2>/dev/null || echo "Failed to list assets"
              
              # Try alternative naming patterns
              echo "Trying alternative asset names..."
              local base_url="https://github.com/ThaUnknown/miru/releases/download/v${NEW_VERSION}/"
              
              # Alternative naming patterns to try
              local alternatives=()
              if [[ "$platform" == "x86_64" ]]; then
                alternatives=(
                  "linux-Hayase-${NEW_VERSION}.AppImage"
                  "linux-Miru-${NEW_VERSION}.AppImage"
                  "linux-x86_64-Hayase-${NEW_VERSION}.AppImage"
                  "linux-x86_64-Miru-${NEW_VERSION}.AppImage"
                  "Hayase-${NEW_VERSION}.AppImage"
                  "Miru-${NEW_VERSION}.AppImage"
                  "hayase-${NEW_VERSION}.AppImage"
                  "miru-${NEW_VERSION}.AppImage"
                )
              else
                alternatives=(
                  "linux-arm64-Hayase-${NEW_VERSION}.AppImage"
                  "linux-arm64-Miru-${NEW_VERSION}.AppImage"
                  "linux-aarch64-Hayase-${NEW_VERSION}.AppImage"
                  "linux-aarch64-Miru-${NEW_VERSION}.AppImage"
                  "Hayase-${NEW_VERSION}-arm64.AppImage"
                  "Miru-${NEW_VERSION}-arm64.AppImage"
                  "hayase-${NEW_VERSION}-arm64.AppImage"
                  "miru-${NEW_VERSION}-arm64.AppImage"
                )
              fi
              
              for alt in "${alternatives[@]}"; do
                local alt_url="${base_url}${alt}"
                echo "Trying: $alt_url"
                if curl --head --silent --fail "$alt_url"; then
                  echo "✓ Found alternative: $alt_url"
                  url="$alt_url"
                  break
                fi
              done
              
              # If still no luck, return failure
              if ! curl --head --silent --fail "$url"; then
                echo "✗ No valid asset found for $platform"
                return 1
              fi
            fi
            echo "✓ URL exists: $url"
            
            # Method 1: Direct nix-prefetch-url
            echo "Trying nix-prefetch-url method 1..."
            local hash
            hash=$(nix-prefetch-url --type sha256 "$url" 2>&1)
            local exit_code=$?
            
            echo "nix-prefetch-url output: $hash"
            echo "nix-prefetch-url exit code: $exit_code"
            
            if [[ $exit_code -eq 0 && -n "$hash" ]]; then
              # Convert to sri format if it's a hex hash
              if [[ $hash =~ ^[a-f0-9]{64}$ ]]; then
                echo "Converting hex hash to SRI format..."
                hash="sha256-$(echo -n "$hash" | xxd -r -p | base64 -w 0)"
              fi
              echo "✓ Got $platform hash (method 1): $hash"
              echo "$hash"
              return 0
            fi
            
            # Method 2: Try without --type flag
            echo "Trying nix-prefetch-url method 2 (without --type)..."
            hash=$(nix-prefetch-url "$url" 2>&1)
            exit_code=$?
            
            echo "nix-prefetch-url output (method 2): $hash"
            echo "nix-prefetch-url exit code (method 2): $exit_code"
            
            if [[ $exit_code -eq 0 && -n "$hash" ]]; then
              # If it's already in SRI format, use it directly
              if [[ $hash =~ ^sha256- ]]; then
                echo "✓ Got $platform hash (method 2): $hash"
                echo "$hash"
                return 0
              fi
              # If it's hex, convert to SRI
              if [[ $hash =~ ^[a-f0-9]{64}$ ]]; then
                hash="sha256-$(echo -n "$hash" | xxd -r -p | base64 -w 0)"
                echo "✓ Got $platform hash (method 2, converted): $hash"
                echo "$hash"
                return 0
              fi
            fi
            
            # Method 3: Try downloading and hashing locally
            echo "Trying local download and hash method..."
            local temp_file=$(mktemp)
            if curl -L -o "$temp_file" "$url" 2>/dev/null; then
              # Use sha256sum and convert to SRI format
              hash=$(sha256sum "$temp_file" | cut -d' ' -f1)
              if [[ -n "$hash" && $hash =~ ^[a-f0-9]{64}$ ]]; then
                hash="sha256-$(echo -n "$hash" | xxd -r -p | base64 -w 0)"
                echo "✓ Got $platform hash (method 3): $hash"
                rm -f "$temp_file"
                echo "$hash"
                return 0
              fi
              rm -f "$temp_file"
            fi
            
            echo "✗ All methods failed for $platform hash"
            return 1
          }

          # Get URLs for both platforms
          X86_64_URL="https://github.com/ThaUnknown/miru/releases/download/v${NEW_VERSION}/linux-Hayase-${NEW_VERSION}.AppImage"
          AARCH64_URL="https://github.com/ThaUnknown/miru/releases/download/v${NEW_VERSION}/linux-arm64-Hayase-${NEW_VERSION}.AppImage"

          echo "URLs to fetch:"
          echo "x86_64: $X86_64_URL"
          echo "aarch64: $AARCH64_URL"

          # Initialize success flags
          X86_64_SUCCESS=0
          AARCH64_SUCCESS=0

          # Get hashes with better error handling
          echo "=== Attempting to fetch x86_64 hash ==="
          if X86_64_HASH=$(get_hash "$X86_64_URL" "x86_64"); then
            X86_64_SUCCESS=1
            echo "SUCCESS: x86_64 hash: $X86_64_HASH"
          else
            echo "FAILED: Failed to get x86_64 hash, using placeholder"
            X86_64_HASH="sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
          fi

          echo "=== Attempting to fetch aarch64 hash ==="
          if AARCH64_HASH=$(get_hash "$AARCH64_URL" "aarch64"); then
            AARCH64_SUCCESS=1
            echo "SUCCESS: aarch64 hash: $AARCH64_HASH"
          else
            echo "FAILED: Failed to get aarch64 hash, using placeholder"
            AARCH64_HASH="sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
          fi

          # Update hashes in flake.nix using more robust sed commands
          echo "Updating x86_64 hash..."
          sed -i '/x86_64-linux = {/,/};/{
            s/hash = "[^"]*"/hash = "'"$X86_64_HASH"'"/
          }' flake.nix

          echo "Updating aarch64 hash..."
          sed -i '/aarch64-linux = {/,/};/{
            s/hash = "[^"]*"/hash = "'"$AARCH64_HASH"'"/
          }' flake.nix

          echo "Updated flake.nix with:"
          echo "  Version: $NEW_VERSION"
          echo "  x86_64 hash: $X86_64_HASH"
          echo "  aarch64 hash: $AARCH64_HASH"

          # Verify the changes were made
          echo "Verifying changes in flake.nix:"
          grep -A 5 -B 5 "version = " flake.nix
          grep -A 3 "x86_64-linux = {" flake.nix
          grep -A 3 "aarch64-linux = {" flake.nix

      - name: Test flake build
        if: steps.check_release.outputs.needs_update == 'true'
        run: |
          echo "Testing flake build..."
          # Try to build the flake to ensure it's valid
          nix build .#default --no-link --print-build-logs || {
            echo "Build failed, but continuing with update"
            echo "This might be due to placeholder hashes"
          }

      - name: Update flake.lock
        if: steps.check_release.outputs.needs_update == 'true'
        run: |
          echo "Updating flake.lock..."
          nix flake update --commit-lock-file

      - name: Commit and push changes
        if: steps.check_release.outputs.needs_update == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Check if there are changes to commit
          if git diff --quiet && git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          git add flake.nix flake.lock
          git commit -m "Update Hayase to v${{ steps.check_release.outputs.new_version }}"
          git push

      - name: Create release
        if: steps.check_release.outputs.needs_update == 'true'
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: "v${{ steps.check_release.outputs.new_version }}"
          name: "Hayase v${{ steps.check_release.outputs.new_version }}"
          body: |
            Automatic update to Hayase v${{ steps.check_release.outputs.new_version }}

            This release automatically tracks the upstream Hayase releases.

            **Installation:**
            ```bash
            nix run github:${{ github.repository }}
            ```

            **Or add to your configuration:**
            ```nix
            {
              inputs.hayase.url = "github:${{ github.repository }}";
              # ... rest of your config
            }
            ```
          draft: false
          prerelease: false
